#!/usr/bin/env python

from flask import Flask, jsonify
import sqlite3
import RPi.GPIO as GPIO
import time
import rest
import random
from threading import Thread
import smtplib

app = Flask(__name__)

stripe_colors = {"red" : 0,"blue" : 46920,"green" : 25500}
free_colors = {"red" : True, "blue" : True, "green" : True}
code_colors = {"red" : "#ffFF0000","blue" : "#ff0000FF","green" : "#ff00FF00"}
NR_SENSORI = 2
LIGHT_ID = 4

base_url = 'http://192.168.0.201'
# example username, generated by following https://www.developers.meethue.com/documentation/getting-started
username = '81bKY8Mv72vDI3thhR8qTh-QhNavYsLPO9MC54Ox'

db_path='init.db'

def init():
    # lettura dati sui bidoni da sqlite3 database
    conn = sqlite3.connect(db_path)
    curs = conn.cursor()
    curs.execute("SELECT * FROM trash ORDER BY SensorID")
    tmp = curs.fetchall()
    curs.close()
    conn.close()

    # restituisce una lista di dizionari, ad ogni dizionario corrisponde un bidone
    trash = []
    i = 0
    for t in tmp:
        tt = dict()
        tt['id'] = t[0]
        tt['storeName'] = t[1]
        tt['maxVolume'] = t[2]
        tt['currentVolume'] = -1
        tt['type'] = t[3]
        tt['typeOfWaste'] = t[4]
        tt['trig'] = t[5]
        tt['echo'] = t[6]
        trash.append(tt)
        i = i + 1
    return trash

def polling():

    i=0
    called = False
    GPIO.setwarnings(False)
    while (True):
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(trash[i]['trig'], GPIO.OUT)
        GPIO.setup(trash[i]['echo'], GPIO.IN)

        GPIO.output(trash[i]['trig'], False)
        time.sleep(1) #wait 10 microsec
        GPIO.output(trash[i]['trig'], True)
        time.sleep(0.00001) #wait 10 microsec
        GPIO.output(trash[i]['trig'], False)

        #echo=1 per tutto il tempo tra l'invio del segnale e il ritorno
        #acquisisco tempo ultimo in cui echo=0
        while GPIO.input(trash[i]['echo']) == 0:
            pulse_start = time.time()
        # acquisisco tempo ultimo in cui echo=1
        while GPIO.input(trash[i]['echo']) == 1:
            pulse_end = time.time()
        pulse_duration = pulse_end - pulse_start

        distance = pulse_duration * 17150   #cm
        distance = round(distance, 2)
        print ("Distance:", distance, "cm")

        # salva dati relativi al bidone
        trash[i]['currentVolume'] = trash[i]['maxVolume'] - distance
        print(i, ") Maximum Volume: ", trash[i]['maxVolume'] , "cm")
        print(i, ") Current Volume: ", trash[i]['currentVolume'] , "cm")


        if(trash[i]['type']=="wastecontainer" and trash[i]['currentVolume'] >= 0.75*trash[i]['maxVolume'] and called==False):
                called = True
                alert_company()

        GPIO.cleanup()
        i = (i+1)%NR_SENSORI
        time.sleep(3)
        if (i == 0):
            time.sleep(10)

def turnOnStripe(color):

    color_value = colors[color]
    url_to_call = base_url + '/api/' + username + '/lights/' + str(LIGHT_ID) + '/state'
    body = '{ "on" : true, "hue" :' + str(color_value) + '}'
    rest.send('PUT', url_to_call, body, {'Content-Type': 'application/json'})

    # wait 30 seconds...
    time.sleep(30)

    body = '{ "on" : false}'
    rest.send('PUT', url_to_call, body, {'Content-Type': 'application/json'})

    free_colors[color] = True

def alert_company():
    sender = 'psdm.ami17@gmail.com'
    receivers = ['fl.casciaro@gmail.com']

    message = """From: PSDM
    To: Waste Disposal Center
    Subject: Waste Container/s full

    One or more waste containers are full

    """

    username = 'psdm.ami17@gmail.com'
    password = 'vivodiciboetristezza'

    # The actual mail send
    server = smtplib.SMTP('smtp.gmail.com:587')
    server.starttls()
    server.login(username, password)
    server.sendmail(sender, receivers, message)
    server.quit()


@app.route('/')
def start():
    return


# ---------- REST FUNCTION ---------- #

# return the details of a single bin/waste container

@app.route('/api/v1.0/amount/<int:ID>', methods=['GET'])
def get_by_ID(ID):
    tmp = dict()
    for t in trash:
        if(t['id'] == ID):
            tmp=t
    return jsonify({'trash': tmp})



# return the amount of trash in each bin/waste container

@app.route('/api/v1.0/amount/<storeN>', methods=['GET'])
def get_trash(storeN):
    tmp = []
    for t in trash:
        if(t['storeName']==storeN or t['type']=="wastecontainer"):
            tmp.append(t)
    return jsonify({'trash': tmp})


# assign a free colour and light up the stripes

@app.route('/api/v1.0/colour', methods=['GET'])
def colour():
    # choice randomly a free color
    colour = ""
    while(True):
        rand = random.randint(1,3)
        if(rand==1 and free_colors['red']==True):
            colour="red"
            free_colors['red']=False
            break
        if(rand==2 and free_colors['blue']==True):
            colour="blue"
            free_colors['blue']=False
            break
        if(rand==3 and free_colors['green']==True):
            colour="green"
            free_colors['green']=False
            break
    t = Thread(target=turnOnStripe, args=(colour, ))
    t.start()
    c=dict()
    c['code']=code_colors[colour]
    return jsonify({'colour': c})


if __name__ == '__main__':
    # i dati sui bidoni vengono memorizzati in una lista di dizionari
    trash = init()
    t = Thread(target=polling, args=())
    t.start()
    app.run('0.0.0.0', port=8080)
