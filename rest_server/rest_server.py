#!/usr/bin/env python

from flask import Flask, jsonify, request
import sqlite3
import RPi.GPIO as GPIO
import time
import rest
import _thread
import smtplib

app = Flask(__name__)

GPIO.setmode(GPIO.BCM)

trash = []

colors = {"red" : 0,"blue" : 46920,"green" : 25500}
free_colors = {"red" : True, "blue" : True, "green" : True}

NR_SENSORI = 1
LIGHT_ID = 1

base_url = 'http://192.168.0.201'
# example username, generated by following https://www.developers.meethue.com/documentation/getting-started
username = '1jlyVie2nvwtNwl0hv8KdZOO0okdvNcIIdPXWsdX'

def init():
    # lettura dati sui bidoni da sqlite3 database
    conn = sqlite3.connect('init.db')
    curs = conn.cursor()
    curs.execute("SELECT * FROM trash ORDER BY id")
    tmp = curs.fetchall()
    curs.close()
    conn.close()

    # restituisce una lista di dizionari, ad ogni dizionario corrisponde un bidone
    trash = []
    i = 0
    for t in tmp:
        trash[i] = dict()
        trash[i]['id'] = t[0]
        trash[i]['storeName'] = t[1]
        trash[i]['maxVolume'] = t[2]
        trash[i]['currentVolume'] = -1
        trash[i]['type'] = t[3]
        trash[i]['typeOfWaste'] = t[4]
        trash[i]['trig'] = t[5]
        trash[i]['echo'] = t[6]
        i = i + 1
    return trash

def polling():
    i=0
    while (True):
        GPIO.setup(trash[i]['trig'], GPIO.OUT)
        GPIO.setup(trash[i]['echo'], GPIO.IN)
        GPIO.output(trash[i]['trig'], False)
        time.sleep(0.00001) #wait 10 microsec
        GPIO.output(trash[i]['trig'], True)
        time.sleep(0.00001) #wait 10 microsec
        GPIO.output(trash[i]['trig'], False)
        #echo=1 per tutto il tempo tra l'invio del segnale e il ritorno
        #acquisisco tempo ultimo in cui echo=0
        while GPIO.input(trash[i]['echo']) == 0:
            pulse_start = time.time()
        # acquisisco tempo ultimo in cui echo=1
        while GPIO.input(trash[i]['echo']) == 1:
            pulse_end = time.time()
        pulse_duration = pulse_end - pulse_start
        distance = pulse_duration * 17150   #cm
        distance = round(distance, 2)
        #print ("Distance:", distance, "cm")
        # salva dati relativi al bidone
        trash[i]['currentVolume'] = trash[i]['maxVolume'] - distance
        if(trash[i]['type']=="wastecontainer" & trash[i]['currentVolume'] >= 0.75*trash[i]['maxVolume']):
            alert_company()
        GPIO.cleanup()
        i = (i+1)%NR_SENSORI
        if (i == 0):
            time.sleep(30)

def turnOnLights(color):

    color_value = colors[color]
    url_to_call = base_url + '/api/' + username + '/lights' + str(LIGHT_ID) + '/state'
    body = '{ "on" : true, "hue" : color_value}'
    rest.send('PUT', url_to_call, body, {'Content-Type': 'application/json'})

    # wait 30 seconds...
    time.sleep(30)

    body = '{ "on" : false}'
    rest.send('PUT', url_to_call, body, {'Content-Type': 'application/json'})

    free_colors[color] = True

def alert_company():
    sender = 'psdm.ami17@gmail.com'
    receivers = ['fl.casciaro@gmail.com']

    message = """From: PSDM
    To: Waste Disposal Center
    Subject: Waste Container/s full

    One or more waste continers are full

    """

    # Credentials (if needed)
    #username = 'username'
    #password = 'password'

    # The actual mail send
    server = smtplib.SMTP('smtp.gmail.com:587')
    server.starttls()
    #server.login(username, password)
    server.sendmail(sender, receivers, message)
    server.quit()


# main function:
# 1) polling sui vari sensori
# 2) elaborazione dati
# 3) invio notifiche (forse la gestiamo a livello app in maniera stupida)
# 4) avviso centrale (invio mail)

@app.route('/')
def start():
    # i dati sui bidoni verranno memorizzati in una lista di dizionari
    trash = init()
    _thread.start_new_thread(polling())
    return


# ---------- REST FUNCTION ---------- #

# return the amount of trash in each bin/waste container

@app.route('/api/v1.0/amount/<String:storeN>', methods=['GET'])
def get_trash(storeN):
    tmp = []
    for t in trash:
        if( t['storeName'] == storeN or t['type']=="wastecontainer"):
            tmp.append(t)
    return jsonify({'trash': tmp})


# assign a free colour and light up the stripes

@app.route('/api/v1.0/colour', methods=['GET'])
def colour():
    # choice first free color
    color = ""
    for (c,v) in free_colors.item():
        if v == True:
            free_colors[c] = False
            color = c
            break
    _thread.start_new_thread(turnOnLights(), (color,))
    return jsonify({'color': color})


if __name__ == '__main__':
    #app.run('0.0.0.0', port=8080)
    app.run(debug=True)