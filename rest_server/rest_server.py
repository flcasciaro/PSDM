#!/usr/bin/env python

#@author: Francesco Lorenzo Casciaro - Politecnico di Torino - AmI course 2017

from flask import Flask, jsonify
import sqlite3
import RPi.GPIO as GPIO
import time
import rest
import random
from threading import Thread
import smtplib

app = Flask(__name__)

# dictionary for the association between colors and respective codes for the led stripes
stripe_colors = {"red" : 0,"blue" : 46920,"green" : 25500}

#dictionary used in the assignment of the colors
free_colors = {"red" : True, "blue" : True, "green" : True}

# dictionary for the association between colors and respectively codes for the Android app
code_colors = {"red" : "#ffFF0000","blue" : "#ff0000FF","green" : "#ff00FF00"}

NR_COLORS = 3

#in our simulation we use only 2 sensors, one for a bin and another for a waste container
NR_SENSORI = 2

#parameter which need to be setted in function of the bridge configuration
   #in our simulation we only have 1 led stripe
   #in case of major number of stripes we just have to associate the stripes id to the waste containers
   #(with an additional information in the database) and when we choose the waste container,
   #retrieve the light id and turn on the respective stripe
LIGHT_ID = 4

#url of the Philips Bridge
base_url = 'http://192.168.0.201'
#username generated by following https://www.developers.meethue.com/documentation/getting-started
username = '81bKY8Mv72vDI3thhR8qTh-QhNavYsLPO9MC54Ox'

#build the url for the REST call
url_to_call = base_url + '/api/' + username + '/lights/' + str(LIGHT_ID) + '/state'

#database for an initial load of the data about bins/waste containers
db_path='init.db'

#function which initialize the system through the read of a SQLite3 database
def init():
    # open a connection
    conn = sqlite3.connect(db_path)
    #define a cursor
    curs = conn.cursor()
    #execute a query which select all the information about the bin/waste container
    curs.execute("SELECT * FROM trash ORDER BY SensorID")
    #save data in a temporary list
    tmp = curs.fetchall()
    #close cursor and connection
    curs.close()
    conn.close()

    # initialize a list of dictionary with the information readed from the database and return it
    trash = []
    i = 0
    for t in tmp:
        tt = dict()
        tt['id'] = t[0]                       #Sensor ID
        tt['name'] = t[1]                     #Name of the store where the bin is placed / "Name" of the waste container
        tt['maxVolume'] = t[2]                #capacity of the bin / waste container
        tt['currentVolume'] = -1              #amount of trash in a bin / waste container, this parameter will be obtained through a distance-sensor
                                                    #at first time is initialized with a useless value
        tt['type'] = t[3]                     #bin OR wastecontainer
        tt['typeOfWaste'] = t[4]              #type of waste (packaging, plastic, glass, paper) collected in the bin / waste container
        tt['trig'] = t[5]                     #GPIO (on Raspberry) where the Trig pin (of the sensor) is connected
        tt['echo'] = t[6]                     #GPIO (on Raspberry) where the Echo pin (of the sensor) is connected
        tt['called'] = False                  #this parameter will be helpful for the management of "calls" to waste disposal center
        trash.append(tt)
        i = i + 1
    return trash

#function which use the sensors for calculate the current amount of trash in each bin / waste container
#the function will run in "background" with the use of a thread
#whenever is necessary it notify the waste disposal center with the method alert_company()
def polling():
    i=0
    GPIO.setwarnings(False)
    while (True):
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(trash[i]['trig'], GPIO.OUT)
        GPIO.setup(trash[i]['echo'], GPIO.IN)

        GPIO.output(trash[i]['trig'], False)
        time.sleep(0.1) #wait 0.1 sec
        GPIO.output(trash[i]['trig'], True)
        time.sleep(0.00001) #wait 10 microsec
        GPIO.output(trash[i]['trig'], False)

        #echo=1 for all the time between the sending and the receiving of the ultrasonic signal
        #ECHO:   _____------------------------------------________
        #             <----------pulse_duration---------->
        
        #acquire the last instant for which the echo is equal to 0
        while GPIO.input(trash[i]['echo']) == 0:
            pulse_start = time.time()
        #acquire the last instant for which the echo is equal to 1
        while GPIO.input(trash[i]['echo']) == 1:
            pulse_end = time.time()
        
        pulse_duration = pulse_end - pulse_start

        distance = pulse_duration * 17150   #cm
        distance = round(distance, 2)
        #print ("Distance:", distance, "cm")

        # save the data of the respective bin/waste container
        trash[i]['currentVolume'] = trash[i]['maxVolume'] - distance
        
        #DEBUG PRINT:
        #print(i, ") Maximum Volume: ", trash[i]['maxVolume'] , "cm")
        #print(i, ") Current Volume: ", trash[i]['currentVolume'] , "cm")

        #notify the waste disposal center if a waste container is almost full
        if(trash[i]['type']=="wastecontainer" and trash[i]['currentVolume'] >= 0.85*trash[i]['maxVolume'] and trash[i]['called']==False):
                alert_company(trash[i]['name'])
                trash[i]['called']=True
        
        #this conditional code makes re-notifiable a certain waste container       
        elif(trash[i]['type']=="wastecontainer" and trash[i]['currentVolume'] <= 0.15*trash[i]['maxVolume'] and trash[i]['called']==True):
                trash[i]['called']=False

        GPIO.cleanup()
        i = (i+1)%NR_SENSORI
        time.sleep(1)
        #rest for 10 sec when a whole lap over the sensors is over
        if (i == 0):
            time.sleep(3)

#function which send the REST request to the Philips Bridge for turn on the stripes
            #the arg 'colour' is a string with the name of the colour, used for obtain the right Hue value
            #through the dictionary stripe_colors
def turnOnStripe(colour):
    #color_value is a number between 0 and 65535 
    color_value = stripe_colors[colour]
    
    #turn on the stripes...
    body = '{ "on" : true, "hue" :' + str(color_value) + '}'
    rest.send('PUT', url_to_call, body, {'Content-Type': 'application/json'})

    #...wait 20 seconds...
    time.sleep(20)

    #...and finally turn off the stripes
    body = '{ "on" : false}'
    rest.send('PUT', url_to_call, body, {'Content-Type': 'application/json'})

    #makes the colour available for other assignment
    free_colors[colour] = True

#function which send the REST request to the Philips Bridge for turn off the stripes    
def turnOffStripe():

    body = '{ "on" : false}'
    rest.send('PUT', url_to_call, body, {'Content-Type': 'application/json'})

#function which will send a mail to the waste disposal center in case of full (or almost) filling of a waste container
    #the "name" of the waste container (a simply ID) is the arg and is part of the body of the mail
def alert_company(name):
    #define sender and receiver
    sender = 'psdm.ami17@gmail.com'
    receivers = ['fl.casciaro@gmail.com']

    #define the message
    message = """From: PSDM Service
    To: Waste Disposal Center
    Subject: Waste Container FULL

    The waste container: """ + name + """ is full. Please send a truck.

    """

    #sender's details required for the login
    username = 'psdm.ami17@gmail.com'
    password = 'vivodiciboetristezza'

    #send the mail
    server = smtplib.SMTP('smtp.gmail.com:587')
    server.starttls()
    server.login(username, password)
    server.sendmail(sender, receivers, message)
    server.quit()

#the function return the name of the waste container in which the amount of trash of the bin best suit
    #the arg 'currentVolume' rapresents the amount of trash in the bin
def choseWasteContainer(currentVolume):
    wasteContainer = "WasteContainer_X"        #default choice in case there aren't waste containers with enough free space
                                               #and the user must split the trash in two or more waste container
    minFreeSpace = 10000000000      #a very big number
    for t in trash:
        if(t['type']=="wastecontainer"):
            freeSpace = t['maxVolume'] - t['currentVolume']
            if(freeSpace >= currentVolume and freeSpace <= minFreeSpace):
                minFreeSpace = freeSpace
                wasteContainer = t['name']
    return wasteContainer

@app.route('/')
def start():
    return


# ---------- REST FUNCTION ---------- #

#return to the client the details of a single bin / waste container identified by the ID args
#in a JSON format
@app.route('/api/v1.0/amount/<int:ID>', methods=['GET'])
def get_by_ID(ID):
    tmp = dict()
    for t in trash:
        if(t['id'] == ID):
            tmp=t
    return jsonify({'trash': tmp})



# return to the client the amount of trash in each bin (of the store which send the request) and waste container
@app.route('/api/v1.0/amount/<storeN>', methods=['GET'])
def get_trash(storeN):
    tmp = []
    for t in trash:
        if(t['name']==storeN or t['type']=="wastecontainer"):
            tmp.append(t)
    return jsonify({'trash': tmp})


# assign a free colour to the client and light up the stripes with the same colour
@app.route('/api/v1.0/colour/<int:ID>', methods=['GET'])
def colour(ID):
    #choice randomly a free colour and make it unavailable for future clients until the stripes turn off
    colour = ""
    while(True):
        rand = random.randint(1,NR_COLORS)
        if(rand==1 and free_colors['red']==True):
            colour="red"
            free_colors['red']=False
            break
        if(rand==2 and free_colors['blue']==True):
            colour="blue"
            free_colors['blue']=False
            break
        if(rand==3 and free_colors['green']==True):
            colour="green"
            free_colors['green']=False
            break
    #create and start a thread which manages the turn ON and turn OFF of the stripes
    t = Thread(target=turnOnStripe, args=(colour, ))
    t.start()
    c=dict()
    #obtain the color code in an "Android-like" format and return it to the client
    c['code']=code_colors[colour]
    c['wastecontainer'] = "WasteContainer_X"      #default value 
    #if ID is a right value obtain the most suitable waste containers and return its name
    #in other case return the dafault value
    for t in trash:
        if(t['id']==ID):
            currentVolume = t['currentVolume']
            c['wastecontainer'] = choseWasteContainer(currentVolume)
            break
    
    return jsonify({'colour': c})


if __name__ == '__main__':
    #initialize the list of dictionary with the information contained in a database
    trash = init()
    #turn off the led stripes
    turnOffStripe()
    #start a thread that handles sensor readings
    t = Thread(target=polling, args=())
    t.start()
    #start the server on a pubblic address
    app.run('0.0.0.0', port=8080)
